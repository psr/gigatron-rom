_startAddress_      EQU                     0x0200

; Internal variables
serialRawPrev       EQU                     0x0081
register0           EQU                     0x0082
register1           EQU                     register0 + 0x02
register2           EQU                     register0 + 0x04
register3           EQU                     register0 + 0x06
register4           EQU                     register0 + 0x08
register5           EQU                     register0 + 0x0A
register6           EQU                     register0 + 0x0C
register7           EQU                     register0 + 0x0E
register8           EQU                     register0 + 0x10
register9           EQU                     register0 + 0x12
register10          EQU                     register0 + 0x14
register11          EQU                     register0 + 0x16
register12          EQU                     register0 + 0x18
register13          EQU                     register0 + 0x1A
register14          EQU                     register0 + 0x1C
register15          EQU                     register0 + 0x1E
fgbgColour          EQU                     register0 + 0x20
cursorXY            EQU                     register0 + 0x22
midiStream          EQU                     register0 + 0x24
midiDelay           EQU                     register0 + 0x26
frameCountPrev      EQU                     register0 + 0x28
miscFlags           EQU                     register0 + 0x2A
highByteMask        EQU                     register0 + 0x2C

; Internal buffers
textWorkArea        EQU                     0xff00

; Includes
%include            include/gigatron.i
%include            include/macros.i

; Labels
_entryPoint_        EQU                     0x0200
_20                 EQU                     0x032f
_30                 EQU                     0x0348
_40                 EQU                     0x0362
_50                 EQU                     0x037c
_60                 EQU                     0x0390
_70                 EQU                     0x03b4
_80                 EQU                     0x03c0
_90                 EQU                     0x03d3
_drawClock          EQU                     0x03de
_drawDigits         EQU                     0x0409
_drawSeconds        EQU                     0x04b7
_drawMinutes        EQU                     0x04cd
_drawHours          EQU                     0x0524
_drawTicks          EQU                     0x0557
_drawDial           EQU                     0x057c
_eraseSecondHand    EQU                     0x05f4
_drawSecondHand     EQU                     0x0625
_eraseMinuteHand    EQU                     0x0649
_drawMinuteHand     EQU                     0x066d
_eraseHourHand      EQU                     0x0691
_drawHourHand       EQU                     0x06b9
_jitterCircle       EQU                     0x06e1
_else_0x02a7        EQU                     0x029f
_endif_0x02ba       EQU                     0x02b0
_page_0x0300        EQU                     0x0300
_page_0x0400        EQU                     0x0400
_page_0x0500        EQU                     0x0500
_endif_0x054a       EQU                     0x051d
_endif_0x057b       EQU                     0x0548
_next_0x062c        EQU                     0x05df
_page_0x0600        EQU                     0x0600
_next_0x07aa        EQU                     0x06f2
_page_0x08a0        EQU                     0x08a0
_next_0x07c2        EQU                     0x08ae
_end_0x07fb         EQU                     0x08e7

; Variables
_H                  EQU                     0x0030
_M                  EQU                     0x0032
_S                  EQU                     0x0034
_B                  EQU                     0x0036
_HH                 EQU                     0x0038
_MM                 EQU                     0x003a
_SS                 EQU                     0x003c
_Hm12               EQU                     0x003e
_Md12               EQU                     0x0040
_MMd12              EQU                     0x0042
_T                  EQU                     0x0044
_V                  EQU                     0x0046
_A                  EQU                     0x0048
_i                  EQU                     0x004a
_Hx5                EQU                     0x004c
_x                  EQU                     0x004e
_y                  EQU                     0x0050
_ox                 EQU                     0x0052
_oy                 EQU                     0x0054
_cr                 EQU                     0x0056
_cc                 EQU                     0x0058
_oxx                EQU                     0x005a
_oyy                EQU                     0x005c

; Strings
_str_0xff60         EQU                     0xff60
_str_0xff60         DB                      11 'Enter Time ' 0
_str_0xff6d         EQU                     0xff6d
_str_0xff6d         DB                      2 'H:' 0
_str_0xff71         EQU                     0xff71
_str_0xff71         DB                      2 'M:' 0
_str_0xff75         EQU                     0xff75
_str_0xff75         DB                      2 'S:' 0
_str_0xff93         EQU                     0xff93
_str_0xff93         DB                      26 '                          ' 0
_str_0xffaf         EQU                     0xffaf
_str_0xffaf         DB                      1 ':' 0

; Define Bytes
def_bytes_0x60a0    EQU                     0x60a0
def_bytes_0x60a0    DB                      80 85 89 94 98 103 106 110 113 116 119 121 123 124 125 125 125 124 123 121 119 116 113 110 106 103 98 94 89 85 80 75 71 66 62 58 54 50 47 44 41 39 37 36 35 35 35 36 37 39 41 44 47 50 54 57 62 66 71 75 
def_bytes_0x61a0    EQU                     0x61a0
def_bytes_0x61a0    DB                      14 14 15 16 18 20 23 26 29 33 37 41 45 50 54 59 64 68 73 77 82 85 89 92 95 98 100 102 103 104 104 104 103 102 100 98 95 92 89 85 82 77 73 68 64 59 54 50 45 41 37 33 29 26 23 20 18 16 15 14 
def_bytes_0x62a0    EQU                     0x62a0
def_bytes_0x62a0    DB                      80 84 88 91 95 99 102 105 107 110 112 114 115 116 117 117 117 116 115 114 112 110 107 105 102 99 95 91 88 84 80 76 72 69 65 62 58 55 53 50 48 46 45 44 43 43 43 44 45 46 48 50 53 55 58 61 65 69 72 76 
def_bytes_0x63a0    EQU                     0x63a0
def_bytes_0x63a0    DB                      22 22 23 24 25 27 29 32 34 37 41 44 48 51 55 59 63 67 70 74 78 81 84 86 89 91 93 94 95 96 96 96 95 94 93 91 89 86 84 81 78 74 70 67 63 59 55 51 48 44 41 37 34 32 29 27 25 24 23 22 
def_bytes_0x64a0    EQU                     0x64a0
def_bytes_0x64a0    DB                      80 83 86 89 92 95 97 99 102 103 105 106 108 108 109 109 109 108 108 106 105 103 102 99 97 95 92 89 86 83 80 77 74 71 68 66 63 61 58 57 55 54 52 52 51 51 51 52 52 54 55 57 58 61 63 65 68 71 74 77 
def_bytes_0x65a0    EQU                     0x65a0
def_bytes_0x65a0    DB                      30 30 31 31 33 34 36 37 40 42 45 47 50 53 56 59 62 65 68 71 74 76 78 81 82 84 85 87 87 88 88 88 87 87 85 84 82 81 78 76 74 71 68 65 62 59 56 53 50 47 45 42 40 37 36 34 33 31 31 30 

; Define Words

; Lookup Tables
_inputVars_0xff7f   EQU                     0xff7f
_inputVars_0xff7f   DW                      0x0030 0x0032 0x0034 
_inputStrs_0xff85   EQU                     0xff85
_inputStrs_0xff85   DW                      0xff6d 0xff71 0xff75 
_inputTypes_0xff8b  EQU                     0xff8b
_inputTypes_0xff8b  DW                      0x0302 0x0302 0x0302 0x0000 
_input_0xff79       EQU                     0xff79
_input_0xff79       DW                      0xff7f 0xff85 0xff8b 

; Code
_entryPoint_        InitRealTimeProc        
                    InitEqOp                
                    InitNeOp                
                    InitLeOp                
                    InitGeOp                
                    InitLtOp                
                    InitGtOp                
                    Initialise                                              ; INIT

                    LDWI                    505
                    STW                     register0
                    LDI                     238
                    POKE                    register0                       ; poke &h01F9, 238

                    LDI                     48
                    ST                      162                             ; poke 162,BKCOLOUR

                    LDWI                    clearVertBlinds
                    CALL                    giga_vAC                        ; cls

                    LDWI                    505
                    STW                     register0
                    LDI                     0
                    POKE                    register0                       ; poke &h01F9, 0  'enable video

                    PrintString             _str_0xff60
                    LDWI                    0xff79
                    Input                                                   ; input "Enter Time ", H,"H:";2;, M,"M:";2;, S,"S:";2;

                    LD                      0x0e
                    STW                     _B                              ; B=peek(14)

                    LDI                     2
                    ST                      cursorXY
                    LDI                     0
                    ST                      cursorXY + 1
                    LDWI                    atTextCursor
                    CALL                    giga_vAC
                    PrintString             _str_0xff93                     ; at 2,0 : print "                          ";

                    LDW                     _H
                    CALL                    convertEqOpAddr
                    JumpFalse               _else_0x02a7 0                  ; if H=0

                    LDI                     12
                    STW                     _H
                    LDWI                    _endif_0x02ba
                    CALL                    giga_vAC                        ; H=12

_else_0x02a7        LDW                     _H
                    STW                     mathX
                    LDI                     13
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    STW                     _H                              ; H=H%13

_endif_0x02ba       LDW                     _M
                    STW                     mathX
                    LDI                     60
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    STW                     _M                              ; M=M%60

                    LDW                     _S
                    STW                     mathX
                    LDI                     60
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    STW                     _S                              ; S=S%60

                    LDW                     _H
                    STW                     _HH
                    LDW                     _M
                    STW                     _MM
                    LDW                     _S
                    STW                     _SS                             ; HH=H : MM=M : SS=S

                    LDW                     _H
                    STW                     mathX
                    LDI                     12
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    STW                     _Hm12                           ; Hm12=H%12

                    STW                     0xde
                    LDWI                    _page_0x0300
                    CALL                    giga_vAC
_page_0x0300        LDW                     0xde
                    LDW                     _M
                    STW                     mathX
                    LDI                     12
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    STW                     _Md12
                    STW                     _MMd12                          ; Md12=M/12 : MMd12=Md12

                    LDWI                    505
                    STW                     register0
                    LDI                     238
                    POKE                    register0                       ; poke &h01F9, 238  'disable video

                    LDWI                    _drawDial
                    CALL                    giga_vAC                        ; gosub drawDial

                    LDWI                    _drawClock
                    CALL                    giga_vAC                        ; gosub drawClock

                    LDWI                    505
                    STW                     register0
                    LDI                     0
                    POKE                    register0                       ; poke &h01F9, 0  'enable video

_20                 LDW                     _S
                    STW                     mathX
                    LDI                     60
                    STW                     mathY
                    LDWI                    multiply16bit
                    CALL                    giga_vAC
                    STW                     _T
                    LDWI                    3599
                    STW                     _V
                    LDWI                    _50
                    CALL                    giga_vAC                        ; T=S*60 : V=3599 : goto 50

_30                 LDW                     _T
                    SUBW                    _V
                    CALL                    convertGeOpAddr
                    JumpFalse               _40 2
                    LDW                     _T
                    SUBW                    _V
                    STW                     _T
                    LDW                     _M
                    ADDI                    1
                    STW                     _M                              ; if T>=V then T=T-V : M=M+1

_40                 LDW                     _M
                    SUBI                    59
                    CALL                    convertGtOpAddr
                    JumpFalse               _50 3
                    LDW                     _M
                    SUBI                    60
                    STW                     _M
                    LDW                     _H
                    ADDI                    1
                    STW                     _H                              ; if M>59 then M=M-60 : H=H+1

_50                 LDW                     _H
                    SUBI                    12
                    CALL                    convertGtOpAddr
                    JumpFalse               _60 4
                    LDW                     _H
                    SUBI                    12
                    STW                     _H                              ; if H>12 then H=H-12

_60                 LDW                     _T
                    STW                     mathX
                    LDI                     60
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    STW                     _S
                    SUBW                    _SS
                    CALL                    convertNeOpAddr
                    JumpFalse               _70 5
                    LDWI                    _drawClock
                    CALL                    giga_vAC
                    LDW                     _S
                    STW                     _SS                             ; S=T/60 : if S<>SS then gosub drawClock : SS=S

_70                 LDW                     _B
                    STW                     _A
                    LD                      0x0e
                    STW                     _B
                    SUBW                    _A
                    STW                     _A                              ; A=B : B=peek(14) : A=B-A

_80                 LDW                     _A
                    CALL                    convertLtOpAddr
                    JumpFalse               _90 6
                    LDWI                    256
                    ADDW                    _A
                    STW                     _A                              ; if A<0 then A=A+256

_90                 LDW                     _T
                    ADDW                    _A
                    STW                     _T
                    LDWI                    _30
                    CALL                    giga_vAC                        ; T=T+A : goto 30 'use T=T+2500 for debugging

_drawClock          PUSH                    
                    LDWI                    _drawDigits
                    CALL                    giga_vAC                        ; gosub drawDigits

                    LDWI                    _drawSeconds
                    CALL                    giga_vAC                        ; gosub drawSeconds

                    LDWI                    _drawMinutes
                    CALL                    giga_vAC                        ; gosub drawMinutes

                    STW                     0xde
                    LDWI                    _page_0x0400
                    CALL                    giga_vAC
_page_0x0400        LDW                     0xde
                    LDWI                    _drawHours
                    CALL                    giga_vAC                        ; gosub drawHours

                    POP                     
                    RET                                                     ; return

_drawDigits         PUSH                    
                    LDI                     0
                    ST                      162                             ; poke 162,&h00

                    LDI                     12
                    ST                      163
                    LDI                     57
                    ST                      cursorXY
                    LDI                     82
                    ST                      cursorXY + 1
                    LDWI                    atTextCursor
                    CALL                    giga_vAC
                    LDW                     _H
                    STW                     mathX
                    LDI                     10
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    PrintAcInt16            
                    LDW                     _H
                    STW                     mathX
                    LDI                     10
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    PrintAcInt16            
                    PrintString             _str_0xffaf
                    LDW                     _M
                    STW                     mathX
                    LDI                     10
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    PrintAcInt16            
                    LDW                     _M
                    STW                     mathX
                    LDI                     10
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    PrintAcInt16            
                    PrintString             _str_0xffaf
                    LDW                     _S
                    STW                     mathX
                    LDI                     10
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    PrintAcInt16            
                    LDW                     _S
                    STW                     mathX
                    LDI                     10
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    PrintAcInt16                                            ; poke 163,&h0C : at 57,82 : print H/10;H%10;":";M/10;M%10;":";S/10;S%10;

                    LDI                     16
                    ST                      162                             ; poke 162,DIALCOLOUR

                    POP                     
                    RET                                                     ; return

_drawSeconds        PUSH                    
                    LDWI                    _eraseSecondHand
                    CALL                    giga_vAC                        ; gosub eraseSecondHand

                    LDW                     _SS
                    STW                     _i
                    LDWI                    _drawTicks
                    CALL                    giga_vAC                        ; i=SS : gosub drawTicks

                    LDWI                    _drawSecondHand
                    CALL                    giga_vAC                        ; gosub drawSecondHand

                    POP                     
                    RET                                                     ; return

_drawMinutes        PUSH                    
                    LDW                     _M
                    SUBW                    _MM
                    CALL                    convertNeOpAddr
                    JumpFalse               _endif_0x054a 8                 ; if M<>MM

                    LDWI                    _eraseMinuteHand
                    CALL                    giga_vAC                        ; gosub eraseMinuteHand

                    LDW                     _M
                    STW                     _MM
                    LDW                     _M
                    STW                     mathX
                    LDI                     12
                    STW                     mathY
                    LDWI                    divide16bit
                    STW                     0xde
                    LDWI                    _page_0x0500
                    CALL                    giga_vAC
_page_0x0500        LDW                     0xde
                    CALL                    giga_vAC
                    STW                     _Md12                           ; MM=M : Md12=M/12

                    LDW                     _Md12
                    SUBW                    _MMd12
                    CALL                    convertNeOpAddr
                    JumpFalse               _endif_0x054a 7                 ; if Md12<>MMd12

                    LDWI                    _eraseHourHand
                    CALL                    giga_vAC                        ; gosub eraseHourHand

                    LDW                     _Md12
                    STW                     _MMd12                          ; MMd12=Md12

_endif_0x054a       LDWI                    _drawMinuteHand
                    CALL                    giga_vAC                        ; gosub drawMinuteHand

                    POP                     
                    RET                                                     ; return

_drawHours          PUSH                    
                    LDW                     _H
                    SUBW                    _HH
                    CALL                    convertNeOpAddr
                    JumpFalse               _endif_0x057b 9                 ; if H<>HH

                    LDW                     _H
                    STW                     _HH
                    LDW                     _H
                    STW                     mathX
                    LDI                     12
                    STW                     mathY
                    LDWI                    divide16bit
                    CALL                    giga_vAC
                    LDW                     mathRem
                    STW                     _Hm12                           ; HH=H : Hm12=H%12

_endif_0x057b       LDW                     _Hm12
                    LSLW                    
                    LSLW                    
                    ADDW                    _Hm12
                    STW                     _Hx5                            ; Hx5=(Hm12 LSL 2)+Hm12

                    LDWI                    _drawHourHand
                    CALL                    giga_vAC                        ; gosub drawHourHand

                    POP                     
                    RET                                                     ; return

_drawTicks          PUSH                    
                    LDWI                    24736
                    ADDW                    _i
                    PEEK                    
                    STW                     _x                              ; x = peek(SECSX + i)

                    LDWI                    24992
                    ADDW                    _i
                    PEEK                    
                    ADDI                    8
                    STW                     _y                              ; y = peek(SECSY + i) + 8

                    LD                      _y
                    ST                      0xc0 + 1
                    LDW                     0xc0
                    ANDW                    highByteMask
                    ADDW                    _x
                    STW                     0xc0
                    LDI                     63
                    POKE                    0xc0                            ; poke (y LSL 8) + x, &h3F

                    POP                     
                    RET                                                     ; return

_drawDial           PUSH                    
                    LDI                     16
                    ST                      163                             ; poke 163, DIALCOLOUR

                    LDI                     80
                    STW                     drawCircleF_cx
                    LDI                     59
                    STW                     drawCircleF_cy
                    LDI                     43
                    STW                     drawCircleF_r
                    DrawCircleF                                             ; circlef CENTERX, CENTERY, DIALRADIUS

                    LDI                     80
                    STW                     _ox
                    LDI                     59
                    STW                     _oy                             ; ox=CENTERX : oy=CENTERY

                    LDI                     44
                    STW                     _cr
                    LDI                     0
                    STW                     _cc
                    LDWI                    _jitterCircle
                    CALL                    giga_vAC                        ; cr=DIALRADIUS + 1 : cc=&h00 : gosub jitterCircle

                    LDI                     46
                    STW                     _cr
                    LDI                     0
                    STW                     _cc
                    LDWI                    _jitterCircle
                    CALL                    giga_vAC                        ; cr=DIALRADIUS + 3 : cc=&h00 : gosub jitterCircle

                    LDI                     48
                    STW                     _cr
                    LDI                     1
                    STW                     _cc
                    LDWI                    _jitterCircle
                    CALL                    giga_vAC                        ; cr=DIALRADIUS + 5 : cc=&h01 : gosub jitterCircle

                    LDI                     52
                    STW                     _cr
                    LDI                     3
                    STW                     _cc
                    LDWI                    _jitterCircle
                    CALL                    giga_vAC                        ; cr=DIALRADIUS + 9 : cc=&h03 : gosub jitterCircle

                    LDI                     50
                    STW                     _cr
                    LDI                     2
                    STW                     _cc
                    LDWI                    _jitterCircle
                    CALL                    giga_vAC                        ; cr=DIALRADIUS + 7 : cc=&h02 : gosub jitterCircle

                    LDI                     0
                    STW                     _i                              ; for i=0 to TICKS-1

_next_0x062c        LDWI                    _drawTicks
                    CALL                    giga_vAC                        ; gosub drawTicks

                    ForNextLoopInc          _i _next_0x062c 59              ; next i

                    POP                     
                    RET                                                     ; return

_eraseSecondHand    PUSH                    
                    STW                     0xde
                    LDWI                    _page_0x0600
                    CALL                    giga_vAC
_page_0x0600        LDW                     0xde
                    LDI                     16
                    ST                      163
                    LDI                     80
                    STW                     drawLine_x1
                    LDI                     59
                    STW                     drawLine_y1
                    LDWI                    24736
                    ADDW                    _SS
                    PEEK                    
                    STW                     drawLine_x2
                    LDWI                    24992
                    ADDW                    _SS
                    PEEK                    
                    STW                     drawLine_y2
                    DrawLine                                                ; poke 163,DIALCOLOUR : line CENTERX,CENTERY, peek(SECSX + SS),peek(SECSY + SS)

                    POP                     
                    RET                                                     ; return

_drawSecondHand     PUSH                    
                    LDI                     63
                    ST                      163
                    LDI                     80
                    STW                     drawLine_x1
                    LDI                     59
                    STW                     drawLine_y1
                    LDWI                    24736
                    ADDW                    _S
                    PEEK                    
                    STW                     drawLine_x2
                    LDWI                    24992
                    ADDW                    _S
                    PEEK                    
                    STW                     drawLine_y2
                    DrawLine                                                ; poke 163,&h3F : line CENTERX,CENTERY, peek(SECSX + S),peek(SECSY + S)

                    POP                     
                    RET                                                     ; return

_eraseMinuteHand    PUSH                    
                    LDI                     16
                    ST                      163
                    LDI                     80
                    STW                     drawLine_x1
                    LDI                     59
                    STW                     drawLine_y1
                    LDWI                    25248
                    ADDW                    _MM
                    PEEK                    
                    STW                     drawLine_x2
                    LDWI                    25504
                    ADDW                    _MM
                    PEEK                    
                    STW                     drawLine_y2
                    DrawLine                                                ; poke 163,DIALCOLOUR : line CENTERX,CENTERY, peek(MINSX + MM),peek(MINSY + MM)

                    POP                     
                    RET                                                     ; return

_drawMinuteHand     PUSH                    
                    LDI                     42
                    ST                      163
                    LDI                     80
                    STW                     drawLine_x1
                    LDI                     59
                    STW                     drawLine_y1
                    LDWI                    25248
                    ADDW                    _M
                    PEEK                    
                    STW                     drawLine_x2
                    LDWI                    25504
                    ADDW                    _M
                    PEEK                    
                    STW                     drawLine_y2
                    DrawLine                                                ; poke 163,&h2A : line CENTERX,CENTERY, peek(MINSX + M),peek(MINSY + M)

                    POP                     
                    RET                                                     ; return

_eraseHourHand      PUSH                    
                    LDI                     16
                    ST                      163
                    LDI                     80
                    STW                     drawLine_x1
                    LDI                     59
                    STW                     drawLine_y1
                    LDWI                    25760
                    ADDW                    _Hx5
                    ADDW                    _MMd12
                    PEEK                    
                    STW                     drawLine_x2
                    LDWI                    26016
                    ADDW                    _Hx5
                    ADDW                    _MMd12
                    PEEK                    
                    STW                     drawLine_y2
                    DrawLine                                                ; poke 163,DIALCOLOUR: line CENTERX,CENTERY, peek(HOURX + Hx5 + MMd12),peek(HOURY + Hx5 + MMd12)

                    POP                     
                    RET                                                     ; return

_drawHourHand       PUSH                    
                    LDI                     21
                    ST                      163
                    LDI                     80
                    STW                     drawLine_x1
                    LDI                     59
                    STW                     drawLine_y1
                    LDWI                    25760
                    ADDW                    _Hx5
                    ADDW                    _Md12
                    PEEK                    
                    STW                     drawLine_x2
                    LDWI                    26016
                    ADDW                    _Hx5
                    ADDW                    _Md12
                    PEEK                    
                    STW                     drawLine_y2
                    DrawLine                                                ; poke 163,&h15 : line CENTERX,CENTERY, peek(HOURX + Hx5 + Md12),peek(HOURY + Hx5 + Md12)

                    POP                     
                    RET                                                     ; return

_jitterCircle       PUSH                    
                    LDW                     _ox
                    SUBI                    1
                    STW                     _oxx
                    LDW                     _ox
                    ADDI                    1
                    STW                     0xb0
                    LDI                     1
                    STW                     0xb2                            ; for oxx=ox-1 to ox+1

_next_0x07aa        LDW                     _oy
                    SUBI                    1
                    STW                     0xde
                    LDWI                    _page_0x08a0
                    CALL                    giga_vAC
_page_0x08a0        LDW                     0xde
                    STW                     _oyy
                    LDW                     _oy
                    ADDI                    1
                    STW                     0xb4
                    LDI                     1
                    STW                     0xb6                            ; for oyy=oy-1 to oy+1

_next_0x07c2        LDW                     _cc
                    ST                      163                             ; poke 163,cc

                    LDW                     _oxx
                    STW                     drawCircle_cx
                    LDW                     _oyy
                    ADDI                    8
                    STW                     drawCircle_cy
                    LDW                     _cr
                    STW                     drawCircle_r
                    DrawCircle                                              ; circle oxx, oyy, cr

                    ForNextLoopVarPos       _oyy _next_0x07c2 0xb4 0xb6     ; next oyy

                    ForNextLoopVarPos       _oxx _next_0x07aa 0xb0 0xb2     ; next oxx

                    POP                     
                    RET                                                     ; return

_end_0x07fb         BRA                     _end_0x07fb                     ; END



;****************************************************************************************************************************************
;****************************************************************************************************************************************
;* Internal runtime, DO NOT MODIFY PAST THIS POINT, modifications must be made in the original include files                            *
;****************************************************************************************************************************************
;****************************************************************************************************************************************

realTimeProc        EQU     0xffb2
convertEqOp         EQU     0xffbb
convertNeOp         EQU     0xffc4
convertLeOp         EQU     0xffcd
convertGeOp         EQU     0xffd6
convertLtOp         EQU     0xffdf
convertGtOp         EQU     0xffe8
multiply16bit       EQU     0xfeca
divide16bit         EQU     0xfd00
resetVideoTable     EQU     0xfc9f
initClearFuncs      EQU     0xfe00
clearVertBlinds     EQU     0xfe23
clearCursorRow      EQU     0xfb00
drawHLine           EQU     0xfb49
drawLine            EQU     0xfc00
drawLineExt         EQU     0xfcbe
drawLineLoop        EQU     0xfba3
drawLineLoadXY      EQU     0xfa00
drawCircle          EQU     0xfc55
drawCircleExt1      EQU     0xfa2b
drawCircleExt2      EQU     0xfa79
drawCircleF         EQU     0xfdae
input               EQU     0xfe76
inputExt1           EQU     0xfaab
inputExt2           EQU     0xfbdd
inputCursor         EQU     0xf900
inputKeys           EQU     0xf922
inputIntVar         EQU     0xf97d
inputStrVar         EQU     0xf991
inputReturn         EQU     0xf9a8
inputDelete         EQU     0xf800
inputPrint          EQU     0xf9e1
inputNewline        EQU     0xf846
printInit           EQU     0xf85b
printText           EQU     0xfe5d
printDigit          EQU     0xf876
printInt16          EQU     0xfd5a
printChr            EQU     0xfff1
printChar           EQU     0xf898
atTextCursor        EQU     0xfe9d
newLineScroll       EQU     0xf700
integerStr          EQU     0xf75e
realTimeProcAddr    EQU     0x00dc
convertEqOpAddr     EQU     0x00d0
convertNeOpAddr     EQU     0x00d2
convertLeOpAddr     EQU     0x00d4
convertGeOpAddr     EQU     0x00d6
convertLtOpAddr     EQU     0x00d8
convertGtOpAddr     EQU     0x00da


; do *NOT* use register4 to register7 during time slicing if you call realTimeProc
numericLabel        EQU     register0
defaultLabel        EQU     register1
lutLabs             EQU     register2
lutAddrs            EQU     register3
lutIndex            EQU     register8
lutLabel            EQU     register9


                    ; runs real time, (time sliced), code at regular intervals
realTimeProc        PUSH
                    LDWI    realTimeStub                    ; realTimeStub gets replaced by MIDI/SPRITE etc routines
                    CALL    giga_vAC
                    POP
                    RET
                    
realTimeStub        RET


                    ; convert equal to into a boolean
convertEqOp         BEQ     convertEq_1
                    LDI     0
                    RET
convertEq_1         LDI     1
                    RET


                    ; convert not equal to into a boolean
convertNeOp         BNE     convertNe_1
                    LDI     0
                    RET
convertNe_1         LDI     1
                    RET


                    ; convert less than or equal to into a boolean
convertLeOp         BLE     convertLe_1
                    LDI     0
                    RET
convertLe_1         LDI     1
                    RET


                    ; convert greater than or equal to into a boolean
convertGeOp         BGE     convertGe_1
                    LDI     0
                    RET
convertGe_1         LDI     1
                    RET


                    ; convert less than into a boolean
convertLtOp         BLT     convertLt_1
                    LDI     0
                    RET
convertLt_1         LDI     1
                    RET


                    ; convert greater than into boolean
convertGtOp         BGT     convertGt_1
                    LDI     0
                    RET
convertGt_1         LDI     1
                    RET


; do *NOT* use register4 to register7 during time slicing if you call realTimeProc
mathX               EQU     register8
mathY               EQU     register9
mathSum             EQU     register10
mathMask            EQU     register11
mathRem             EQU     register12
mathSign            EQU     register13
mathScratch         EQU     register14
mathShift           EQU     register15
mathBase            EQU     register12
mathPow             EQU     register13
mathResult          EQU     register14


                    ; accumulator = mathX * mathY, (result 16bit)
multiply16bit       LDI     0
                    STW     mathSum
                    LDI     1
    
multiply16_loop     STW     mathMask
                    ANDW    mathY
                    BEQ     multiply16_skip
                    LDW     mathSum
                    ADDW    mathX
                    STW     mathSum
                    
multiply16_skip     LDW     mathX
                    ADDW    mathX
                    STW     mathX
                    LDW     mathMask
                    ADDW    mathMask
                    BNE     multiply16_loop
                    PUSH
                    CALL    realTimeProcAddr
                    POP
                    LDW     mathSum
                    RET


                    ; accumulator:mathRem = mathX / mathY, (results 16bit)
divide16bit         LDW     mathX
                    XORW    mathY
                    STW     mathSign
                    LDW     mathX
                    BGE     divide16_skip0
                    LDI     0
                    SUBW    mathX
                    STW     mathX
                    
divide16_skip0      LDW     mathY                     
                    BGE     divide16_skip1
                    LDI     0
                    SUBW    mathY
                    STW     mathY
                    
divide16_skip1      LDI     0
                    STW     mathRem
    
divide16_loop       STW     mathScratch
                    LDW     mathRem
                    ADDW    mathRem
                    STW     mathRem
                    LDW     mathX
                    BGE     divide16_skip3
                    INC     mathRem
                    
divide16_skip3      LDW     mathX
                    ADDW    mathX
                    STW     mathX
                    LDW     mathRem
                    SUBW    mathY
                    BLT     divide16_skip4
                    STW     mathRem
                    INC     mathX
                    
divide16_skip4      PUSH
                    CALL    realTimeProcAddr
                    POP
                    LDW     mathScratch
                    ADDI    1
                    ANDI    0x0F
                    BNE     divide16_loop
                    LDW     mathSign
                    BGE     divide16_exit
                    LDI     0
                    SUBW    mathX
                    RET
                    
divide16_exit       LDW     mathX
                    RET



; do *NOT* use register4 to register7 during time slicing if you call realTimeProc
xreset              EQU     register0
xcount              EQU     register1
ycount              EQU     register2
treset              EQU     register3
breset              EQU     register8
top                 EQU     register9
bot                 EQU     register10
vramAddr            EQU     register11
evenAddr            EQU     register12
clsAddress          EQU     register13
    
    
                    ; resets video table pointers
resetVideoTable     PUSH
                    LDI     8
                    STW     vramAddr
                    LDWI    giga_videoTable
                    STW     evenAddr
    
resetVT_loop        CALL    realTimeProcAddr
                    LDW     vramAddr
                    DOKE    evenAddr
                    INC     evenAddr
                    INC     evenAddr
                    INC     vramAddr
                    LD      vramAddr
                    SUBI    giga_yres + 8
                    BLT     resetVT_loop
                    POP
                    RET


initClearFuncs      PUSH
                    LDWI    resetVideoTable
                    CALL    giga_vAC
    
                    LDWI    0x0002                              ; starting cursor position
                    STW     cursorXY
                    LDWI    0x7FFF
                    ANDW    miscFlags
                    STW     miscFlags                           ; reset on bottom row flag
            
                    LD      fgbgColour
                    ST      giga_sysArg0
                    ST      giga_sysArg0 + 1
                    ST      giga_sysArg2
                    ST      giga_sysArg2 + 1                    ; 4 pixels of fg colour
    
                    LDWI    SYS_Draw4_30                        ; setup 4 pixel SYS routine
                    STW     giga_sysFn
                    POP
                    RET


                    ; clears the viewable screen using a vertical blinds effect
clearVertBlinds     PUSH
                    LDWI    initClearFuncs
                    CALL    giga_vAC

                    LDWI    giga_vram
                    STW     giga_sysArg4
                    LD      giga_sysArg4 + 1
                    ST      top
    
clearVB_loop        CALL    realTimeProcAddr
                    LD      top
                    ST      giga_sysArg4 + 1                    ; top line
                    SYS     0xFF                                ; SYS_Draw4_30, 270 - 30/2 = 0xFF
    
                    LDWI    giga_yres - 1 + 16
                    SUBW    top
                    ST      giga_sysArg4 + 1                    ; bottom line
                    SYS     0xFF                                ; SYS_Draw4_30, 270 - 30/2 = 0xFF
    
                    LD      giga_sysArg4
                    ADDI    0x04
                    ST      giga_sysArg4
                    SUBI    giga_xres
                    BLT     clearVB_loop
    
                    LDI     0
                    ST      giga_sysArg4
                    INC     top                                 ; next top line
                    LD      top
                    SUBI    giga_yres / 2 + 8
                    BLT     clearVB_loop
                    POP
                    RET




; do *NOT* use register4 to register7 during time slicing if you use realTimeProc
graphicsMode        EQU     register0
waitVBlankNum       EQU     register0

drawHLine_x1        EQU     register0
drawHLine_y1        EQU     register1
drawHLine_x2        EQU     register2
drawHLine_x4        EQU     register3

drawVLine_x1        EQU     register0
drawVLine_y1        EQU     register1
drawVLine_y2        EQU     register2
drawVLine_y8        EQU     register3

drawLine_x1         EQU     register0
drawLine_y1         EQU     register1
drawLine_x2         EQU     register2
drawLine_y2         EQU     register3
drawLine_xy1        EQU     register0
drawLine_xy2        EQU     register1
drawLine_dxy1       EQU     register2
drawLine_dxy2       EQU     register3
drawLine_dx1        EQU     register4           ; register4 to register7 used for temp values, state will be invalidated during time slicing
drawLine_dy1        EQU     register5
drawLine_dx2        EQU     register6
drawLine_dy2        EQU     register7
drawLine_sx         EQU     register8
drawLine_sy         EQU     register9
drawLine_h          EQU     register10
drawLine_num        EQU     register11
drawLine_count      EQU     register12
drawLine_addr       EQU     register13
drawLine_tmp        EQU     register14
  
drawCircle_cx       EQU     register0
drawCircle_cy       EQU     register1
drawCircle_r        EQU     register2
drawCircle_a        EQU     register3
drawCircle_d        EQU     register8
drawCircle_x        EQU     register9
drawCircle_y        EQU     register10
drawCircle_ch0      EQU     register11
drawCircle_ch1      EQU     register12
drawCircle_ch2      EQU     register13
drawCircle_ch3      EQU     register14

drawCircleF_x1      EQU     register0
drawCircleF_y1      EQU     register1
drawCircleF_x2      EQU     register2
drawCircleF_cx      EQU     register15
drawCircleF_cy      EQU     register10
drawCircleF_r       EQU     register11
drawCircleF_v       EQU     register8
drawCircleF_w       EQU     register9

drawRect_x1         EQU     register7
drawRect_y1         EQU     register10
drawRect_x2         EQU     register11
drawRect_y2         EQU     register15

drawRectF_x1        EQU     register0
drawRectF_y1        EQU     register1
drawRectF_x2        EQU     register2
drawRectF_y2        EQU     register7

drawPoly_addr       EQU     register15

    
drawLine            PUSH                        ; matches drawLineLoop's POP
                    LDI     1
                    STW     drawLine_dx1
                    STW     drawLine_dx2
                    STW     drawLine_dy1
                    LDI     0
                    STW     drawLine_dy2                
    
                    LDWI    0x8000
                    STW     drawLine_tmp
                    
                    LDW     drawLine_x2         ; sx = x2 - x1
                    SUBW    drawLine_x1
                    STW     drawLine_sx
                    ANDW    drawLine_tmp        
                    BEQ     drawL_dy
                    LDWI    -1
                    STW     drawLine_dx1        
                    STW     drawLine_dx2        ; dx1 = dx2 = (sx & 0x8000) ? -1 : 1
                    LDI     0                   ; sx = (sx & 0x8000) ? 0 - sx : sx
                    SUBW    drawLine_sx
                    STW     drawLine_sx                
                    
drawL_dy            LDW     drawLine_y2
                    SUBW    drawLine_y1
                    STW     drawLine_sy
                    STW     drawLine_h          ; h = sy
                    ANDW    drawLine_tmp
                    BEQ     drawL_ext
                    
                    LDWI    -1
                    STW     drawLine_dy1        ; dy1 = (sy & 0x8000) ? -1 : 1
                    LDI     0                   
                    SUBW    drawLine_sy
                    STW     drawLine_sy         ; sy = (sy & 0x8000) ? 0 - sy : sy
                    SUBW    drawLine_sx
                    BLE     drawL_ext           
                    LDW     drawLine_dy1
                    STW     drawLine_dy2        ; if(sx < sy) dy2 = -1
    
drawL_ext           LDWI    drawLineLoadXY
                    CALL    giga_vAC
                    LDWI    drawLineExt
                    CALL    giga_vAC



drawLineExt         LDW     drawLine_sy
                    SUBW    drawLine_sx
                    BLE     drawL_num
                    LDI     0
                    STW     drawLine_dx2        ; if(sx < sy) dx2 = 0
                    LDW     drawLine_sy       
                    STW     drawLine_tmp
                    LDW     drawLine_sx
                    STW     drawLine_sy
                    LDW     drawLine_tmp
                    STW     drawLine_sx         ; swap sx with sy
                    LDW     drawLine_h
                    BLE     drawL_num
                    LDI     1
                    STW     drawLine_dy2        ; if(h > 0) dy2 = 1
    
drawL_num           LDWI    SYS_LSRW1_48
                    STW     giga_sysFn          
                    LDW     drawLine_sx
                    SYS     0xF6                ; 0xF6 = 270-max(14,48/2)
                    ADDI    1
                    STW     drawLine_num        ; numerator = sx>>1
                    STW     drawLine_count      ; for(count=sx>>1; counti>=0; --i)
                    
                    LDWI    drawLineLoadDXY
                    CALL    giga_vAC
                    LDWI    drawLineLoop
                    CALL    giga_vAC


drawLineLoop        LD      fgbgColour + 1
                    POKE    drawLine_xy1        ; plot start pixel
                    POKE    drawLine_xy2        ; plot end pixel, (meet in middle)
                    
                    LDW     drawLine_num        ; numerator += sy
                    ADDW    drawLine_sy
                    STW     drawLine_num
                    SUBW    drawLine_sx
                    BLE     drawL_flip          ; if(numerator <= sx) goto flip
                    STW     drawLine_num        ; numerator -= sx
                    
                    LDW     drawLine_xy1
                    ADDW    drawLine_dxy1
                    STW     drawLine_xy1        ; xy1 += dxy1
                    
                    LDW     drawLine_xy2
                    SUBW    drawLine_dxy1
                    STW     drawLine_xy2        ; xy2 -= dxy1
                    BRA     drawL_count
                    
drawL_flip          LDW     drawLine_xy1        
                    ADDW    drawLine_dxy2
                    STW     drawLine_xy1        ; xy1 += dxy2
                    
                    LDW     drawLine_xy2        
                    SUBW    drawLine_dxy2
                    STW     drawLine_xy2        ; xy2 -= dxy2
                    
drawL_count         CALL    realTimeProcAddr
                    LDW     drawLine_count
                    SUBI    0x01
                    STW     drawLine_count
                    BGT     drawLineLoop
                    POP                         ; matches drawLine's PUSH
                    RET


drawLineLoadXY      LD      drawLine_x1
                    ST      drawLine_xy1
                    LD      drawLine_y1
                    ADDI    8
                    ST      drawLine_xy1 + 1    ; xy1 = x1 | ((y1+8)<<8)
                    
                    LD      drawLine_x2
                    ST      drawLine_xy2
                    LD      drawLine_y2
                    ADDI    8
                    ST      drawLine_xy2 + 1    ; xy2 = x2 | ((y2+8)<<8)
                    RET
                    
drawLineLoadDXY     LDWI    SYS_LSLW8_24
                    STW     giga_sysFn          
                    LDW     drawLine_dy1
                    SYS     0x00                ; LSL 8, 0x00 = 270-max(14,24/2)
                    ADDW    drawLine_dx1
                    STW     drawLine_dxy1       ; dxy1 = dx1 + (dy1<<8)
    
                    LDW     drawLine_dy2
                    SYS     0x00                ; LSL 8, 0x00 = 270-max(14,24/2)
                    ADDW    drawLine_dx2
                    STW     drawLine_dxy2       ; dxy2 = dx2 + (dy2<<8)
                    RET



drawCircle          PUSH
                    LDI     0
                    STW     drawCircle_ch0
                    STW     drawCircle_ch1
                    STW     drawCircle_ch2
                    STW     drawCircle_ch3
                    STW     drawCircle_x
                    LDW     drawCircle_r
                    STW     drawCircle_y
                    LDI     1
                    SUBW    drawCircle_r
                    STW     drawCircle_d
                    
drawC_loop          LDWI    drawCircleExt1
                    CALL    giga_vAC
                    
                    LDW     drawCircle_d
                    BGE     drawC_skip
                    LDW     drawCircle_x
                    LSLW
                    LSLW
                    ADDW    drawCircle_d
                    ADDI    3
                    STW     drawCircle_d
                    BRA     drawC_cont
                    
drawC_skip          LDW     drawCircle_x
                    SUBW    drawCircle_y
                    LSLW
                    LSLW
                    ADDW    drawCircle_d
                    ADDI    5
                    STW     drawCircle_d
                    LDW     drawCircle_y
                    SUBI    1
                    STW     drawCircle_y

drawC_cont          INC     drawCircle_x
                    LDW     drawCircle_x
                    SUBW    drawCircle_y
                    BLE     drawC_loop

                    POP
                    RET



drawCircleExt1      PUSH
                    LDW     drawCircle_cy
                    ADDW    drawCircle_y
                    ST      drawCircle_ch0 + 1
                    LDW     drawCircle_cy
                    SUBW    drawCircle_y
                    ST      drawCircle_ch1 + 1
                    LDW     drawCircle_cy
                    ADDW    drawCircle_x
                    ST      drawCircle_ch2 + 1
                    LDW     drawCircle_cy
                    SUBW    drawCircle_x
                    ST      drawCircle_ch3 + 1

                    LDW     drawCircle_cx
                    ADDW    drawCircle_x
                    ADDW    drawCircle_ch0
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a

                    LDW     drawCircle_cx
                    SUBW    drawCircle_x
                    ADDW    drawCircle_ch0
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a
                    
                    LDW     drawCircle_cx
                    ADDW    drawCircle_x
                    ADDW    drawCircle_ch1
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a

                    LDW     drawCircle_cx
                    SUBW    drawCircle_x
                    ADDW    drawCircle_ch1
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a
                    
                    LDWI    drawCircleExt2
                    CALL    giga_vAC            ; doesn't return to here


drawCircleExt2      LDW     drawCircle_cx
                    ADDW    drawCircle_y
                    ADDW    drawCircle_ch2
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a

                    LDW     drawCircle_cx
                    SUBW    drawCircle_y
                    ADDW    drawCircle_ch2
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a
                    
                    LDW     drawCircle_cx
                    ADDW    drawCircle_y
                    ADDW    drawCircle_ch3
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a

                    LDW     drawCircle_cx
                    SUBW    drawCircle_y
                    ADDW    drawCircle_ch3
                    STW     drawCircle_a
                    LD      fgbgColour + 1
                    POKE    drawCircle_a
                    
                    POP
                    RET



drawHLine           PUSH
                    LDW     drawHLine_x2
                    SUBW    drawHLine_x1
                    BGE     drawHL_cont
                    LDW     drawHLine_x2
                    STW     drawLine_tmp
                    LDW     drawHLine_x1
                    STW     drawHLine_x2
                    LDW     drawLine_tmp
                    STW     drawHLine_x1        ; if x2 < x1 then swap x2 with x1
                    
drawHL_cont         LD      drawHLine_x1
                    ST      giga_sysArg4
                    LD      drawHLine_y1
                    ADDI    8
                    ST      giga_sysArg4 + 1
                    LDW     drawHLine_x2
                    SUBW    drawHLine_x1
                    SUBI    4
                    BLT     drawHL_loop1
                    
                    LD      fgbgColour + 1
                    ST      giga_sysArg0
                    ST      giga_sysArg0 + 1
                    ST      giga_sysArg2
                    ST      giga_sysArg2 + 1    ; 4 pixels of fg colour
                    LDWI    SYS_Draw4_30        ; setup 4 pixel SYS routine
                    STW     giga_sysFn
                    
                    LDW     drawHLine_x2        
                    SUBI    3
                    STW     drawHLine_x4        ; 4 pixel chunks limit

drawHL_loop0        SYS     0xFF                ; SYS_Draw4_30, 270 - 30/2 = 0xFF
                    CALL    realTimeProcAddr
                    LD      giga_sysArg4
                    ADDI    4
                    ST      giga_sysArg4
                    SUBW    drawHLine_x4
                    BLT     drawHL_loop0        ; all 4 pixel chunks
                    
drawHL_loop1        LD      fgbgColour + 1
                    POKE    giga_sysArg4
                    INC     giga_sysArg4
                    LD      giga_sysArg4
                    SUBW    drawHLine_x2
                    BLE     drawHL_loop1        ; remaining pixels
                    POP
                    RET


drawCircleF         PUSH
                    LDI     0
                    STW     drawCircleF_v
                    STW     drawCircleF_w
                    
drawCF_wloop        LDW     drawCircleF_cx
                    SUBW    drawCircleF_r
                    STW     drawCircleF_x1
                    LDW     drawCircleF_cx
                    ADDW    drawCircleF_r
                    STW     drawCircleF_x2
                    LDW     drawCircleF_cy
                    SUBW    drawCircleF_v
                    STW     drawCircleF_y1
                    LDWI    drawHLine
                    CALL    giga_vAC
                    LDW     drawCircleF_cy
                    ADDW    drawCircleF_v
                    STW     drawCircleF_y1
                    LDWI    drawHLine
                    CALL    giga_vAC
                    
                    LDW     drawCircleF_w
                    ADDW    drawCircleF_v
                    ADDW    drawCircleF_v
                    ADDI    1
                    STW     drawCircleF_w
                    INC     drawCircleF_v
                    
drawCF_rloop        LDW     drawCircleF_w
                    BLT     drawCF_wloop
                    LDW     drawCircleF_w
                    SUBW    drawCircleF_r
                    SUBW    drawCircleF_r
                    ADDI    1
                    STW     drawCircleF_w
                    LDW     drawCircleF_r
                    SUBI    1
                    STW     drawCircleF_r
                    BGT     drawCF_rloop
                    POP
                    RET



; do *NOT* use register4 to register7 during time slicing if you use realTimeProc
inpLutAddr          EQU     register0
inpKeyBak           EQU     register0
inpVarsAddr         EQU     register1
inpStrsAddr         EQU     register2
inpTypesAddr        EQU     register4
inpTextAddr         EQU     register5
inpTextOfs          EQU     register6
inpTypeData         EQU     register7
inpTextEnd          EQU     register8
printXYBak          EQU     register11
cursXYBak           EQU     register12
frmCntBak           EQU     register13
cursorChr           EQU     register14
cursXYOfs           EQU     register15

cursorDelay         EQU     30

    
                    ; inputs numerics and text into vars
input               PUSH
                    LDW     inpLutAddr
                    DEEK
                    STW     inpVarsAddr         ; vars LUT address
                    LDW     inpLutAddr
                    ADDI    2
                    DEEK
                    STW     inpStrsAddr         ; strings LUT address
                    LDW     inpLutAddr
                    ADDI    4
                    DEEK
                    STW     inpTypesAddr        ; types LUT address

                    LD      giga_serialRaw
                    ST      serialRawPrev       ; initialise previous keystroke
                    LD      giga_frameCount
                    ADDI    cursorDelay
                    STW     frmCntBak           ; delay for cursor flash
                    LDI     127
                    STW     cursorChr           ; cursor char
                    LDWI    inputExt1
                    CALL    giga_vAC            ; doesn't return to here




                    ; input extended 1
inputExt1           LDW     inpTypesAddr
                    DEEK
                    BEQ     inputE1_exit        ; exit on LUT delimiter
                    STW     inpTypeData         ; high byte is max string length, 8th and 7th bits of low byte are newline, last 6 bits of low byte is type
                    ANDI    0x40
                    BEQ     inputE1_print       ; check for newline
                    LDWI    inputNewline
                    CALL    giga_vAC
                    
inputE1_print       LDW     inpStrsAddr
                    DEEK
                    STW     textStr
                    LDWI    printText           ; print strings LUT
                    CALL    giga_vAC
                    LD      inpTypeData         ; high byte is max string length, 8th and 7th bits of low byte are newline, last 6 bits of low byte is type
                    ANDI    0x80
                    BEQ     inputE1_skip        ; check for newline
                    LDWI    inputNewline
                    CALL    giga_vAC
                    
inputE1_skip        LDWI    textWorkArea + 1
                    STW     inpTextAddr         ; text work area, treated as a string so skip length
                    LDI     0
                    STW     inpTextOfs          ; print text offset
                    LDWI    textWorkArea
                    STW     inpTextEnd          ; print text end
                    LD      inpTypeData + 1
                    ADDW    inpTextEnd
                    STW     inpTextEnd          ; text max = textWorkArea + (highByte(inpTypeData) >> 8)
                    
                    LDW     cursorXY
                    STW     cursXYBak
                    STW     printXYBak
                    LDWI    inputExt2
                    CALL    giga_vAC            ; doesn't return to here
                    
inputE1_exit        LDI     0x01
                    ORW     miscFlags
                    STW     miscFlags           ; enable text scrolling
                    POP
                    RET




                    ; input extended 2
inputExt2           LDWI    inputCursor
                    CALL    giga_vAC
                    LDWI    inputKeys
                    CALL    giga_vAC
                    BEQ     inputExt2           ; loop until return key pressed

                    INC     inpVarsAddr
                    INC     inpVarsAddr
                    INC     inpStrsAddr
                    INC     inpStrsAddr
                    INC     inpTypesAddr
                    INC     inpTypesAddr
                    LDWI    inputExt1
                    CALL    giga_vAC            ; doesn't return to here



                    ; flashes cursor
inputCursor         LD      giga_frameCount
                    SUBW    frmCntBak
                    BEQ     inputC_toggle
                    RET
                    
inputC_toggle       PUSH
                    LD      giga_frameCount
                    ADDI    cursorDelay
                    ST      frmCntBak           ; delay for cursor flash
                    LD      cursorChr
                    ST      textChr
                    XORI    0xDF
                    ST      cursorChr           ; toggle between 127 and 32 for cursor char
                    LDW     cursXYBak
                    STW     cursorXY            ; restore cursor position after the printChr
                    LDWI    printChr
                    CALL    giga_vAC
                    POP
                    RET





                    ; saves key press into string work area buffer
inputKeys           PUSH
                    LD      giga_serialRaw
                    STW     inpKeyBak           ; save keystroke
                    LD      serialRawPrev
                    SUBW    inpKeyBak
                    BEQ     inputK_exit         ; if keystroke hasn't changed exit
                    LD      inpKeyBak
                    ST      serialRawPrev       ; save as previous keystroke
                    SUBI    127
                    BGT     inputK_exit
                    BNE     inputK_ret
                    LDWI    inputDelete         ; delete key
                    CALL    giga_vAC            ; doesn't return to here
                    
inputK_ret          LD      inpKeyBak
                    SUBI    10
                    BNE     inputK_char
                    LDWI    inputReturn         ; return key
                    CALL    giga_vAC            ; doesn't return to here
                    
inputK_char         LDW     inpTextEnd
                    SUBW    inpTextAddr
                    BEQ     inputK_exit         ; text string bounds, (check after delete and return keys)
                    LD      inpKeyBak
                    SUBI    32
                    BLT     inputK_exit
                    LD      inpKeyBak
                    POKE    inpTextAddr         ; set char
                    INC     inpTextAddr
                    LDI     0
                    POKE    inpTextAddr         ; set new end of text string
                    LD      cursXYBak
                    SUBI    giga_xres - 11
                    BLT     inputK_advance      ; cursor max bounds
                    INC     inpTextOfs
                    LDI     0
                    BRA     inputK_print
                    
inputK_advance      LDI     6
                    
inputK_print        STW     cursXYOfs           ; advance cursor
                    LDWI    inputPrint
                    CALL    giga_vAC            ; doesn't return to here
                    
inputK_exit         LDI     0                   ; keep looping on current var
                    POP
                    RET                    



inputStrVar         LDWI    textWorkArea
                    STW     register11          ; src str address
                    LDW     inpVarsAddr
                    DEEK
                    STW     register12          ; dst var address

inputS_copy         LDW     register11
                    PEEK
                    POKE    register12
                    INC     register11
                    INC     register12
                    BNE     inputS_copy         ; copy char until terminating char
                    RET




inputIntVar         PUSH
                    LDWI    textWorkArea + 1
                    STW     intSrcAddr          ; src str address, (skip length)
                    LDW     inpVarsAddr
                    DEEK
                    STW     register12          ; dst int address
                    LDWI    integerStr
                    CALL    giga_vAC
                    DOKE    register12          ; convert string to integer
                    POP
                    RET


inputReturn         LDI     32
                    STW     cursorChr
                    LDWI    inputC_toggle
                    CALL    giga_vAC            ; erase cursor
                    
                    LDWI    textWorkArea
                    STW     register0
                    LDW     inpTextAddr
                    SUBW    register0
                    SUBI    1
                    POKE    register0           ; text length
                    ADDW    register0
                    ADDI    1
                    STW     register0
                    LDI     0
                    POKE    register0           ; text delimiter
                    
                    LD      inpTypeData         ; check var tye
                    ANDI    0x3F                ; var type is bottom 6 bits
                    SUBI    3                   ; var is string or integer?
                    BNE     inputR_int
                    LDWI    inputStrVar
                    CALL    giga_vAC            ; copy string
                    BRA     inputR_exit
                    
inputR_int          LDWI    inputIntVar
                    CALL    giga_vAC            ; convert numeric

inputR_exit         LDI     1                   ; return key pressed, next var
                    POP
                    RET


inputDelete         LD      inpTextOfs
                    BEQ     inputD_bounds
                    SUBI    1
                    STW     inpTextOfs          ; decrement print text offset
                    LDI     0
                    STW     cursXYOfs           ; stationary cursor
                    LDI     0
                    POKE    inpTextAddr         ; delimiter
                    LDW     inpTextAddr
                    SUBI    1
                    STW     inpTextAddr         ; decrement text pointer
                    LDI     32                  
                    POKE    inpTextAddr         ; delete char
                    BRA     inputD_print

inputD_bounds       LDW     printXYBak
                    SUBW    cursXYBak
                    BGE     inputD_exit         ; cursor min bounds
                    LDWI    -6
                    STW     cursXYOfs           ; retreat cursor
                    LDI     32                  
                    POKE    inpTextAddr         ; delete cursor
                    INC     inpTextAddr
                    LDI     0
                    POKE    inpTextAddr         ; delimiter
                    LDW     inpTextAddr
                    SUBI    2
                    STW     inpTextAddr         ; decrement text pointer
                    LDI     32                  
                    POKE    inpTextAddr         ; delete char
                    
inputD_print        LDWI    inputPrint
                    CALL    giga_vAC            ; doesn't return to here
                    
inputD_exit         LDI     0                   ; keep looping on current var
                    POP
                    RET


inputPrint          LDWI    inputCursor
                    CALL    giga_vAC            ; call cursor flash frequently
                    LDWI    textWorkArea
                    ADDW    inpTextOfs
                    STW     textStr
                    LDW     printXYBak
                    STW     cursorXY            ; restore cursor position after the printText
                    LDWI    printText
                    CALL    giga_vAC
                    LDW     cursXYBak           ; new cursor position
                    ADDW    cursXYOfs
                    STW     cursXYBak
                    LDI     0                   ; keep looping on current var
                    POP
                    RET



inputNewline        PUSH
                    LDI     0x01
                    ORW     miscFlags
                    STW     miscFlags           ; enable text scrolling
                    LDWI    newLineScroll
                    CALL    giga_vAC            ; new line
                    LDWI    0xFFFE
                    ANDW    miscFlags
                    STW     miscFlags           ; disable text scrolling
                    POP
                    RET



; do *NOT* use register4 to register7 during time slicing if you use realTimeProc
textStr             EQU     register0
textNum             EQU     register0
textBak             EQU     register0
textLen             EQU     register1
textOfs             EQU     register2
textChr             EQU     register3
textHex             EQU     register8
textFont            EQU     register9
textSlice           EQU     register10
scanLine            EQU     register11
digitMult           EQU     register12
digitIndex          EQU     register13
clearLoop           EQU     register14
    
    
printInit           LDWI    SYS_VDrawBits_134
                    STW     giga_sysFn
                    LDW     fgbgColour
                    STW     giga_sysArg0
                    
                    LDWI    giga_videoTable
                    STW     giga_sysArg4
                    LD      cursorXY + 1
                    LSLW
                    ADDW    giga_sysArg4
                    PEEK
                    ST      giga_sysArg4 + 1
                    LD      cursorXY
                    ST      giga_sysArg4                    ; xy position
                    RET



                    ; prints text string pointed to by textStr
printText           PUSH
                    LDWI    printInit
                    CALL    giga_vAC

                    ; first byte is length
printT_char         INC     textStr                         ; next char
                    LDW     textStr             
                    PEEK
                    BEQ     printT_exit                     ; check for delimiting zero
                    ST      textChr
                    LDWI    printChar
                    CALL    giga_vAC
                    BRA     printT_char
                    
printT_exit         POP
                    RET



                    ; prints single digit in textNum
printDigit          PUSH
                    LDW     textNum
printD_index        SUBW    digitMult
                    BLT     printD_cont
                    STW     textNum
                    INC     digitIndex
                    BRA     printD_index
    
printD_cont         LD      digitIndex
                    BEQ     printD_exit
                    ORI     0x30
                    ST      textChr
                    LDWI    printChar
                    CALL    giga_vAC
                    LDI     0x30
                    ST      digitIndex
printD_exit         POP
                    RET


                    ; prints 16bit int in textNum
printInt16          PUSH
                    LDWI    printInit
                    CALL    giga_vAC
                    LDI     0
                    ST      digitIndex
                    LDW     textNum
                    BGE     printI16_pos
                    LDI     0x2D
                    ST      textChr
                    LDWI    printChar
                    CALL    giga_vAC
                    LDWI    0
                    SUBW    textNum
                    STW     textNum    
    
printI16_pos        LDWI    10000
                    STW     digitMult
                    LDWI    printDigit
                    CALL    giga_vAC
                    LDWI    1000
                    STW     digitMult
                    LDWI    printDigit
                    CALL    giga_vAC
                    LDWI    100
                    STW     digitMult
                    LDWI    printDigit
                    CALL    giga_vAC
                    LDWI    10
                    STW     digitMult
                    LDWI    printDigit
                    CALL    giga_vAC
                    LD      textNum
                    ORI     0x30
                    ST      textChr
                    LDWI    printChar
                    CALL    giga_vAC
                    POP
                    RET


                    ; prints char in textChr for standalone calls
printChr            PUSH
                    LDWI    printInit
                    CALL    giga_vAC
                    LDWI    printChar
                    CALL    giga_vAC
                    POP
                    RET


                    ; prints char in textChr
printChar           LD      textChr
                    ANDI    0x7F                            ; char can't be bigger than 127
                    SUBI    82
                    BGE     printC_text82
                    ADDI    50
                    BLT     printC_exit                     ; char<32 exit
                    STW     textChr                         ; char-32
                    LDWI    giga_text32                     ; text font slice base address for chars 32-81
                    BRA     printC_font
                    
printC_text82       STW     textChr                         ; char-82
                    LDWI    giga_text82                     ; text font slice base address for chars 82+
                    
printC_font         STW     textFont
                    LD      textChr
                    LSLW    
                    LSLW    
                    ADDW    textChr
                    ADDW    textFont
                    STW     textFont                        ; char*5 + textFont
                    LDI     0x05

printC_slice        ST      textSlice
                    LDW     textFont                        ; text font slice base address
                    LUP     0x00                            ; get ROM slice
                    ST      giga_sysArg2
                    SYS     0xCB                            ; draw vertical slice, SYS_VDrawBits_134, 270 - 134/2 = 0xCB
                    INC     textFont                        ; next vertical slice
                    INC     giga_sysArg4                    ; next x
                    LD      textSlice
                    SUBI    1
                    BNE     printC_slice
                    
                    ST      giga_sysArg2                    ; result of printC_slice is 0
                    SYS     0xCB                            ; draw last blank slice
                    INC     giga_sysArg4                    ; using sysArg4 as a temporary cursor address for multiple char prints
                    
                    PUSH
                    CALL    realTimeProcAddr
                    LD      cursorXY
                    ADDI    0x06
                    ST      cursorXY
                    SUBI    giga_xres - 5                   ; giga_xres - 6, (154), is last possible char in row
                    BLT     printC_pop
                    LDWI    newLineScroll                   ; next row, scroll at bottom
                    CALL    giga_vAC
                    
printC_pop          POP

printC_exit         RET


atTextCursor        LD      cursorXY
                    SUBI    giga_xres
                    BLT     atTC_skip0
                    LDI     0
                    ST      cursorXY
                    
atTC_skip0          LD      cursorXY + 1
                    SUBI    giga_yres
                    BLT     atTC_skip1
                    LDI     giga_yres - 1
                    ST      cursorXY + 1
                    
atTC_skip1          LD      cursorXY + 1
                    SUBI    giga_yres - 8
                    BGE     atTC_skip2
                    LDWI    0x7FFF
                    ANDW    miscFlags
                    STW     miscFlags                       ; reset on bottom row flag
                    RET
                    
atTC_skip2          LDWI    0x8000
                    ORW     miscFlags
                    STW     miscFlags                       ; set on bottom row flag
                    RET



                    ; clears the top 8 lines of pixels in preparation of text scrolling
clearCursorRow      PUSH
                    LD      fgbgColour
                    ST      giga_sysArg0
                    ST      giga_sysArg0 + 1
                    ST      giga_sysArg2
                    ST      giga_sysArg2 + 1                ; 4 pixels of colour
    
                    LDWI    SYS_Draw4_30                    ; setup 4 pixel SYS routine
                    STW     giga_sysFn
    
                    LDWI    giga_videoTable                 ; current cursor position
                    PEEK
                    ST      giga_sysArg4 + 1
                    LDI     8

clearCR_loopy       ST      clearLoop
                    CALL    realTimeProcAddr
                    LDI     giga_xres
                    
clearCR_loopx       SUBI    4                               ; loop is unrolled 4 times
                    ST      giga_sysArg4
                    SYS     0xFF                            ; SYS_Draw4_30, 270 - 30/2 = 0xFF
                    SUBI    4
                    ST      giga_sysArg4
                    SYS     0xFF                            ; SYS_Draw4_30, 270 - 30/2 = 0xFF
                    SUBI    4
                    ST      giga_sysArg4
                    SYS     0xFF                            ; SYS_Draw4_30, 270 - 30/2 = 0xFF
                    SUBI    4
                    ST      giga_sysArg4
                    SYS     0xFF                            ; SYS_Draw4_30, 270 - 30/2 = 0xFF
                    BGT     clearCR_loopx
                    
                    INC     giga_sysArg4 + 1                ; next line
                    LD      clearLoop
                    SUBI    1
                    BNE     clearCR_loopy

                    LDWI    printInit
                    CALL    giga_vAC                        ; re-initialise the SYS registers
                    POP
                    RET


                    ; print from top row to bottom row, then start scrolling 
newLineScroll       LDI     0x02                            ; x offset slightly
                    ST      cursorXY
                    ST      giga_sysArg4
                    LDWI    0x0001
                    ANDW    miscFlags
                    BNE     newLS_cont0                     ; scroll on or off
                    RET
                    
newLS_cont0         PUSH
                    LDWI    0x8000
                    ANDW    miscFlags                       ; on bottom row flag
                    BNE     newLS_cont1
                    LD      cursorXY + 1
                    ADDI    8
                    ST      cursorXY + 1
                    SUBI    giga_yres
                    BLT     newLS_exit
                    LDI     giga_yres - 8
                    ST      cursorXY + 1
                    
newLS_cont1         LDWI    clearCursorRow
                    CALL    giga_vAC
                    LDWI    giga_videoTable
                    STW     scanLine
    
newLS_scroll        CALL    realTimeProcAddr
                    LDW     scanLine
                    PEEK
                    ADDI    8
                    ANDI    0x7F
                    SUBI    8
                    BGE     newLS_adjust
                    ADDI    8
                    
newLS_adjust        ADDI    8
                    POKE    scanLine
                    INC     scanLine                        ; scanline pointers are 16bits
                    INC     scanLine
                    LD      scanLine
                    SUBI    0xF0                            ; scanline pointers end at 0x01EE
                    BLT     newLS_scroll
                    
                    LDWI    0x8000
                    ORW     miscFlags
                    STW     miscFlags                       ; set on bottom row flag
                    
newLS_exit          LDWI    printInit
                    CALL    giga_vAC                        ; re-initialise the SYS registers
                    POP
                    RET


; do *NOT* use register4 to register7 during time slicing if you call realTimeProc
intSrcAddr          EQU     register8
intDigit            EQU     register9
intResult           EQU     register10
intNegative         EQU     register11
intTemp0            EQU     register12
intTemp1            EQU     register15


                    ; converts a string to a +/- integer, assumes string pointer is pointing to first char and not the string length, (no overflow or underflow checks)
integerStr          LDI     0
                    ST      intNegative
                    STW     intResult
                    LDW     intSrcAddr
                    PEEK
                    SUBI    45                  ; -ve
                    BNE     integerS_loop
                    LDI     1
                    ST      intNegative
                    INC     intSrcAddr          ; skip -ve

integerS_loop       LDW     intSrcAddr
                    PEEK
                    SUBI    48                  ; str[i] - '0'
                    BLT     integerS_neg
                    STW     intDigit
                    SUBI    9
                    BGT     integerS_neg
                    LDW     intResult
                    LSLW
                    LSLW
                    ADDW    intResult
                    LSLW
                    ADDW    intDigit
                    STW     intResult           ; result = result*10 + digit
                    INC     intSrcAddr
                    BRA     integerS_loop
          
integerS_neg        LD      intNegative
                    BEQ     integerS_exit
                    LDI     0
                    SUBW    intResult           ; result *= -1
                    RET
                    
integerS_exit       LDW     intResult
                    RET

